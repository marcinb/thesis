% Copyright 2011, Piotr Jakubowski

\chapter{Solution development}
  \section{Creating a RubyGem}
    The first step in creating the plugin is setting up the structure of directories and creating necessary
    files for this plugin to be available for installation. Chapter 3.2 provided basic information about
    the RubyGems standard. This chapter will provide some further details on how the structure for particular
    RubyGem has been created.

    \subsection{Structure of directories}
      The essential structure of directories needed in RubyGem standard is a \texttt{gemspec} file in the
      root directory of the Gem and the \texttt{lib/} directory containing Ruby file with the name
      corresponding to the name of the Gem. So in the case of the Gem described in the application,
      which would be called Administer, the name of the file would be \texttt{lib/administer.rb}. This
      file is automatically loaded when the Gem is added to the program. You could put all the code
      in that file, but as the project gets bigger it is common practice to split the code into multiple
      files and require those files in the main (\texttt{administer.rb}) file.

      Instead of creating the structure manually, there are plenty of options that would help create
      the structure automatically. The one to be considered the best recently is using bundler, which is
      a gem for managing other gems in the application. Bundler among others, provides \texttt{bundle gem}
      command which creates structure needed for the newly created Gem. Moreover, it initializes \texttt{git}
      repository in the Gem directory for Version Control:

      \lstinputlisting{code/chapter04/gem01}

    \subsection{Gemspec}
      The \texttt{bundle gem} command creates a template for gemspec file:

      \lstinputlisting{code/chapter04/gem02}

      The gemspec file defines the specification of the gem. In addition to the attributes visible
      above (which are self-explanatory) there are few other that may be pretty important:
      \begin{description}
        \item[add\_dependency] Adds other gem as dependency
        \item[add\_development\_dependency] Adds ohter gem as dependency for development
      \end{description}

    \subsection{Gem building}
      When the gem's code is ready it is necessary to create a package. It can be achieved by running

       \begin{lstlisting}
          gem build gem_name.gemspec
        \end{lstlisting}

      This results in creating \texttt{.gem} package, which is a binary file.

    \subsection{Gem publishing}
      It is possible to distribute gem by sending the \texttt{.gem} file to other people via email or
      putting in on ftp server. But, there is unified way of distributing gems which is
      \texttt{rubygems.org} server.

      Publishing gem on \texttt{rubygems.org} is as easy as running

      \begin{lstlisting}
        gem push name_of_package.gem
       \end{lstlisting}

      where \texttt{name\_of\_package.gem} is a file we got after building the gem. In order to be able to
      push to rubygems developer has to have an account and will be prompted for login credentials.
  \section{Scrum}
    In order to ensure that the works both on Master Thesis and on the plugin go smoothly and according to
    plan I decided to use SCRUM methodology to lead the project. As SCRUM is usually intended for
    multi-person teams, it needed to be slightly adapted for the needs of the project of this Master Thesis.
    Nonetheless, it helped to evenly distribute workload in time ad avoid exhausting bursts of intensive work
    when some deadline was approaching.

    \subsection{What is Scrum?}
      The idea behind Scrum is to divide the entire project into very small subprojects that can be done in
      intervals of up to 4 weeks. Such intervals are called \texttt{sprints}. The result of sprint is
      supposed to be part of the project that can be added to the production system. So most likely, it would
      be a complete feature that can be developed independently of other pending features and added to the
      existing system, what would accomplish the \texttt{sprint}.

      Before the project kicks off, the target functionality is discussed and decided. The functionality is
      then divided into features that would together build the product. Next, the difficulty of every feature
      is discussed and estimates on needed time and resources are drawn. This step is very important, as
      all next steps in the project would depend on this initial one.

      Each sprint would begin with a short team meeting with a purpose of drawing appropriate number
      of features from the backlog that would be implemented during that particular sprint. As it can be
      observed, the estimates from the initial step would become useful at this step as the team
      knows how much work would approximately it take to finish particular feature. Then the features are
      prioritized.

      During the sprint, developers take the features from the top of sprint's backlog and try to finish
      all of them before the end of the sprint. As the features has been selected to fit the workforce of the
      team for particular sprint, this should be doable without overtimes and stressful situations.

      Moreover, some implementations of Scrum introduce very short daily meetings, a purpose of which is
      to keep everyone in the team informed about the status of the work done as well as discussing problems
      that appeared.

      The sprint ends with a team meeting that reviews the performance, what has been done and what could not
      be completed. In addition, problems are discussed and conclusions are drawn for the future sprints.

    \subsection{Scrum for Master Thesis}
      As the Master Thesis should be and usually is a single person effort not all parts of Scrum can be
      implemented for the purpose of creating one. Nonetheless, the idea of dividing the whole project
      into very small and short steps helped me to create the plan of work. Moreover, in order to
      embrace the power of meetings as motivational tool I contacted one of Ruby on Rails companies located
      in Łódź in order to organise weekly meeting with Ruby on Rails mentor. He would weekly review my
      work, help me with solving programming problems and guide into the world of Ruby programming best practices.
      Moreover, about every month I tried to contact my supervisor in order to share and discuss my progress.

      As for planning work for my weekly sprints, I used Pivotal Tracker\footnote{http://pivotaltracker.com}
      to keep track of all tasks that needed to be done in order to get closer to finishing the project.
      In the begining, when starting the Master Thesis, I decided how the programming project should look like and what
      would be the parts of the report I would hand in and I would sort all of those issues according to
      what should be done first. That would create my backlog. Then every week I dragged appropriate number of tasks
      to the "current" section and at the end of the week I would get asked about.

      Not surprisingly, such arrangement helped to keep me motivated throughout the entire process and
      helped me avoid stress of deadlines and the feeling of not knowing where to go next.


