% Copyright 2011, Marcin Baliński

\chapter[Studium przypadku: Dynamicznie generowany panel administracyjny]{Studium przypadku: Dynamicznie generowany panel administracyjny}
  \section{Wstęp}
  Świat technologii informatycznych zmienia się bardzo szybko. Ogromnemu skokowi mocy obliczeniowej sprzętu komputerowego towarzyszył w ostatnich kilku latach znaczący spadek cen związanych z jego wykorzystaniem. Stało się to katalizatorem rozwoju nowych trendów między innymi w dziedzinie wytwarzania oprogramowania. Gwałtowny wzrost zainteresowania dynamicznymi językami programowania takimi jak Ruby, Python czy JavaScript oraz pojawienie się nowych metodyk rozwoju produktów informatycznych, które coraz częściej ujmują ten proces bardziej z filozoficznego aniżeli technicznego lub biznesowego punktu widzenia jest bez wątpienia jednym z owoców tego procesu.
  
  Spadek kosztów mocy obliczeniowej skutecznie rozwiązał problem wyboru technologii realizacji projektu informatycznego: wydajność narzędzi, których użyjemy do realizacji celu stała się w większości przypadków pomijalnym lub przynajmniej drugorzędnym problemem. Dziś najważniejszym kryterium wyboru jest stopień dopasowania możliwości oraz charakterystyki rozważanej technologii do potrzeb zespołu odpowiedzialnego za rozwój projektu. Oczywiście istnieją również skrajne przypadki, w których to oprogramowanie, z różnych przyczyn, musi zostać napisane w konkretnej technologii. Te smutne przypadki stanowią jednak kroplę w morzu wykraczającą daleko poza ramy niniejszej pracy.
  
  W czasach, kiedy o wiele bardziej opłaca się dokupić nowy serwer niż pokrywać koszty optymalizacji ogromną furorę robi termin \"Przedwczesna optymalizacja\". Te dwa słowa mają dzisiaj znaczenie negatywne, które jest jednak jak najbardziej uzasadnione z ekonomicznego oraz użytkowego punktu widzenia. Dopóki niedostatki w wydajności oprogramowania można skompensować inwestycją w nowe zasoby sprzętowe zespół programistów powinien skupiać wszystkie swoje wysiłki na rozwój funkcjonalności. Optymalizacja kodu następuje dopiero w momencie, kiedy koszty inwestycji w sprzęt przewyższają koszt związane z optymalizacją albo w momencie kiedy oprogramowanie ze względu na swoją nie optymalność przestaje się skalować na nowe zasoby sprzętowe.
  
  Na pierwszy rzut oka może wydawać się, że ten wstęp niewiele ma wspólnego z tematem pracy. Należy jednak uświadomić sobie, że to właśnie opisane powyżej zmiany w sposobie myślenia o metodach prowadzenia projektów IT stoją u podstaw rozwoju nowoczesnych narzędzi takich jak wymienione wcześniej dynamiczne języki, wysokopoziomowe frameworki programistyczne na nich oparte czy metodologie pokroju Behaviour Driven Development. Środki, które służą osiągnięciu założonego celu są jedną z najważniejszych zmiennych od których zależy sukces projektu, w przeszłości istniało wiele barier ograniczających ich wybór, dziś większość z nich została usunięta.
  
  \section{Założenia projektu}
  Celem niniejszego rozdziału jest pokazanie czytelnikowi w jaki sposób rozwija się konkretny projekt prowadzony w zgodzie z metodologią BDD oraz jakie płyną z tego korzyści. Wybrany temat projektu to dynamiczny panel administracyjny dla aplikacji internetowych opartych na bibliotece Ruby on Rails, jego główne założenia to:
  
  \begin{description}
    \item[Uniwersalność] Panel powinien współpracować z większością aplikacji napisanych w Ruby on Rails. W praktyce oznacza to, że jeśli modele biznesowe powinny być klasami pochodnymi klasy \verb+ActiveRecord+ a sposób budowy aplikacji jest zgodny z konwencjami przyjętymi dla aplikacji Ruby on Rails.
    \item[CRUD] W teorii baz danych istnieją cztery podstawowe operacje jakie możemy wykonać na zasobie: Tworzenie, odczytanie, aktualizacja, usunięcie (ang. Create, read, update and delete). Biblioteka ma pozwalać na zarządzanie modelami biznesowymi aplikacji przy użyciu jedynie tych czterech standardowych metod.
    \item[Dynamiczność] Po instalacji panel powinien sam wykryć rodzaje zasobów na jakich operuje aplikacja oraz wygenerować odpowiednie widoki i formularze do zarządzania nimi. Zmiany w budowie modeli biznesowych, które wymuszają konieczność zmian w zarządzaniu nimi, jak również pojawienie się nowych modeli również powinno być odzwierciedlone w zachowaniu panelu automatycznie, bez konieczności jakiejkolwiek ingerencji.
    \item[Proste wdrożenie] Podstawowe wdrożenie rozwiązania wymaga jedynie aby aplikacja kliencka korzystała z biblioteki Ruby on Rails w wersji co najmniej 3.0.3. Po dodaniu biblioteki panelu do listy gemów wykorzystywanych przez aplikację możliwe jest natychmiastowe korzystanie.
    \item[Wygoda użytkowania] Proces zarządzania aplikacją powinien być jak najwygodniejszy. Oznacza to między innymi, że pola formularzy służących do tworzenia lub edycji rekordów powinny być dostosowane do rodzaju danych jakie przechowują a próby wprowadzenia nieprawidłowych wartości powinny być sygnalizowane czytelną informacją o błędzie. Jeśli istnieją powiązania pomiędzy kilkoma modelami biznesowymi, to powinna istnieć bardzo szybka możliwość zarządzania każdym z powiązanych rekordów.
  \end{description}
  
  \subsection{Open Source}
    Biblioteka jest dostępna za darmo na zasadach licencji MIT.\footnote{http://en.wikipedia.org/wiki/MIT\_License} Filozofia rozwoju oprogramowania na zasadach open source jest bardzo bliska środowisku programistów Ruby. Sam język udostępniony jest na licencji GPL, biblioteka Ruby on Rails korzysta z licencji MIT. Użycie licencji MIT oznacza, że każdy otrzymuje prawo do nielimitowanego wykorzystania kopii oprogramowania w dowolny sposób, sprawia to, że jest to najchętniej wykorzystywana przez programistów Ruby licencja.
    
  \subsection{Sposób prowadzenia projektu}
  Projekt prowadzony jest według bardzo uproszczonych zasad metodologii SCRUM.\footnote{http://en.wikipedia.org/wiki/Scrum\_(development)} \nocite{wiki_scrum} Rozwój projektu podzielony jest na tygodniowe sprinty, przed każdym z nich następuje spotkanie zespołu, podczas którego wybierane i przydzielane są konkretne zadania do wykonania w następnej iteracji. Spotkania te służą również omówieniu bieżących spraw związanych z projektem.
  
  Zespół zaangażowany w projekt składa się z trzech osób: dwóch programistów, oraz osoby dzielącej rolę Scrum Mastera, który odpowiedzialny jest za przygotowanie i prowadzenie spotkań oraz Product Ownera, który reprezentuje oczekiwania końcowego użytkownika dotyczące kwestii funkcjonalności oraz ekonomicznych kwestii związanych z rozwojem projektu.
  
  Duży nacisk kładziony jest na testowanie oprogramowania, testy akceptacyjne istnieją w formie zautomatyzowanych scenariuszy BDD. Każda funkcjonalność lub modyfikacja oprogramowania akceptowana jest jedynie jeśli dostarczona jest wraz z pełnym zestawem testów ją dokumentujących.
  
  \subsection{Dodatkowe narzędzia}
  Repozytorium projektu zarządzane jest przez system kontroli wersji GIT\footnote{http://git\-scm.com} a hostowane jest przez serwis GitHub.\footnote{http://github.com} Źródła projektu dostępne są publicznie pod adresem https://github.com/piotrj/administer.
  
  Jako narzędzie wspomagające proces zarządzania projektem użyta została darmowa wersja Pivotal Tracker\footnote{http://www.pivotaltracker.com}, który został zaprojektowany aby wspomagać zarządzanie projektem prowadzonym według zasad SCRUM.
  
  % może inna nazwa?
  \section{Proces implementacji}
  
  Jak zostało to wspomniane wcześniej implementacja podzielona jest na tygodniowe iteracje zwane również sprintami. Każda planowana funkcjonalność zanim zostanie zaimplementowana i stanie się częścią projektu musi zostać krytycznie oceniona pod względem użyteczności oraz opisana w formie krótkiej specyfikacji.
  
  W wypadku kiedy mamy do czynienia z rozbudowaną funkcjonalnością należy podzielić jej implementację na jak najmniejsze, spójne kawałki a każdy z tych fragmentów powinien zostać jasno opisany. Idealnie jest, kiedy fragmenty danej funkcjonalności są od siebie niezależne, to znaczy, jeśli nad każdym z nich można pracować osobno w tym samym czasie. Taka sytuacja niestety zdarza się rzadko. Jeśli dany fragment zależy od innych, należy załączyć taką informację w jego opisie.
  
  Każde nowe zachowanie opisane jest testem w postaci odpowiedniego scenariusza Cucumber. Jest to warunek konieczny, scenariusze powstają przed rozpoczęciem procesu właściwej implementacji, po zaakceptowaniu przez Product Ownera pełnią one rolę testów akceptacyjnych. Testy jednostkowe w postaci specyfikacji RSpec powstają dla części systemu, których szczegóły implementacji są istotne dla prawidłowego jego działania.
  
  \subsection{Aplikacja testowa}
  Specyfika projektu dynamicznego panelu administracyjnego utrudnia nieco pisanie scenariuszy jego użycia. Myśląc o panelu administracyjnym nigdy nie myślimy o nim jako o odrębnym bycie, jest raczej nieodłącznie związany z aplikacją, którą administruje. Aby proces testowania i specyfikowania systemu był jak najbardziej naturalny biblioteka \emph{administer} rozwijana jest wraz z małą aplikacją testową.
  
  Prosty system blogowy został stworzony, aby opisać i przetestować zachowanie właściwego oprogramowania. Jedynym celem istnienia aplikacji blogowej jest przetestowanie integracji biblioteki \emph{administer} z zewnętrzną aplikacją. Z technicznego punktu widzenia wszystkie testy behawioralne opisują zachowanie aplikacji testowej, która dołącza bibliotekę \emph{administer} do puli wykorzystywanych przez siebie gemów. W przypadku oprogramowania, które działa na zasadzie integracji z zewnętrznym systemem taka konfiguracja środowiska testowego jest najlepsza, odpowiada bowiem faktycznemu scenariuszowi użycia. Sam blog jest niezwykle prostą aplikacją, w założeniach ma pozwalać na:
  
  \begin{itemize}
    \item Wyświetlanie artykułów
    \item Tworzenie artykułów
    \item Edycję artykułów
    \item Usuwanie artykułów
    \item Kategoryzację artykułów
    \item Tworzenie kategorii
    \item Edycję kategorii
    \item Usuwanie kategorii
  \end{itemize}
  
  % PRZEREDAGOWAĆ
  Blog świetnie nadaje się do testowania biblioteki typu \emph{administer} - wszystkie powyższe funkcje, prócz pierwszej, są tak naprawdę funkcjami, które wykonywać ma panel administracyjny. W kontekście tego przykładu cel biblioteki \emph{administer} jest jasny: Twórca bloga ze swojej strony musi jedynie dołączyć gem \emph{administer} do projektu, zdefiniować modele biznesowe typu Post czy Kategoria, oraz dopisać akcję odpowiedzialną za wyświetlanie artykułów, cała część odpowiedzialna za akcję zarządzania modelami ma być dynamicznie wykonywana przez gem \emph{administer}. 
  
  Ilustracja \ref{blog_view} przedstawia stronę z listą artykułów, jest to widok pochodzący z aplikacji testowej. Ilustracja \ref{administer_edit} przedstawia widok edycji rekordu konkretnego artykułu, funkcja ta implementowana jest przez bibliotekę administer.
  
  \begin{figure}[!h]
		\begin{center}
			\includegraphics[width=\linewidth]{images/blog.png}
			\caption{Aplikacja testowa - wyświetlanie artykułów}
			\label{blog_view}
		\end{center}
	\end{figure}
	
	\clearpage
	
	\begin{figure}[!h]
		\begin{center}
			\includegraphics[width=\linewidth]{images/administer_edit.png}
			\caption{administer - edycja rekordu}
			\label{administer_edit}
		\end{center}
	\end{figure}
  
  % lepsza nazwa
  \subsection{Konfiguracja zależności testowych}
    % aplikacja testowa powinna kożystać ze źródeł testowanego gema, nie z jego release
    % Test dependencies - warto coś o tym napisać?
    
  % zdecydowanie zmień nazwę tej sekcji 
  \subsection{Implementacja funkcji usuwania rekordu}
    % screen z listą tiketów
    % dokładny opis całego procesu + wycinki kodu źródłowego dla konkretnego tiketa
    
    Ilustracja \ref{administer_stories}  przedstawia wycinek listy zadań związanych z pracą nad projektem \emph{administer} a konkretnie są to zadania związane z rozwojem panelu administracyjnego.
    
    \clearpage
    
    \begin{figure}
  		\begin{center}
  			\includegraphics[width=\linewidth]{images/administer_stories_list.png}
  			\caption{Lista zadań do wykonania}
  			\label{administer_stories}
  		\end{center}
  	\end{figure}
  	
    Jako, że projekt jest rozwijany już od jakiegoś czasu, większość zadań z tej listy jest już wykonana, znajdziemy jednak dwa nadal nie rozwiązane problemy:
    
    \begin{itemize}
      \item Deletion of model records
      \item Display validation errors in administer
    \end{itemize}
    
    Skupmy się na rozwiązaniu pierwszego z nich. W momencie pisania tego rozdziału gem \emph{administer} potrafi już tworzyć, modyfikować oraz wyświetlać informacje o rekordach modeli biznesowych aplikacji, która z niego korzysta. Jedną z brakujących funkcji jest usuwanie istniejących rekordów. W tym podrozdziale przeanalizujemy krok po kroku cały cykl wdrażania tej nowej funkcji do istniejącego systemu. Przeanalizowanie tego procesu pomoże nam lepiej zrozumieć sposób w jaki rozwijane jest oprogramowanie w zgodzie z zasadami BDD oraz korzyści z tego płynące.
    
    \subsubsection{Zrozumienie problemu}
    Pierwszy etap pracy to rozpoznanie, z czym tak właściwie mamy do czynienia. Jeśli problem, który mamy rozwiązać został wcześniej udokumentowany, tak jak miało to miejsce w tym wypadku, należy zacząć od dokładnego zaznajomienia się z jego opisem.
    
    Ilustracja \ref{administer_story_desc} przedstawia szczegółowy widok naszego zadania prezentowany przez aplikację Pivotal Tracker, która używana jest jako narzędzie wspomagające proces zarządzania projektem \emph{administer}.
    
    Podgląd ten informuje nas o wielu rzeczach związanych z zadaniem takich jak status ukończenia, estymacja pracochłonności czy informacja o osobach odpowiedzialnych za zadanie. W kontekście naszych rozważań najważniejszą informacją jaką możemy odczytać z niniejszego podglądu jest jednak opis funkcjonalności. 
    
    \emph{Administer} rozwijany jest razem z prostą aplikacją testową - systemem blogowym, dlatego wszystkie funkcjonalności opisywane są w kontekście wykorzystania biblioteki przez ten właśnie system. Opis naszego zadania sformułowany jest następująco:
    
    \lstinputlisting{examples/code/ch04/01}
    
    Na pierwszy rzut oka widać, że opis dostarczony został w postaci, której bez modyfikacji można użyć jako scenariusza akceptacyjnego biblioteki cucumber. Należy także zwrócić uwagę na inne ważne cechy tego opisu:
    
    \begin{description}
      \item[Niepodzielność] Dostarczone kroki stanowią minimum, jakie trzeba zaimplementować aby funkcjonalność usuwania rekordów była kompletna.
      \item[Osadzenie w kontekście] Zachowanie zostało opisane w konkretnych warunkach. Mamy informację o stanie początkowym w jakim funkcjonalność powinna działać (Istnieje rekord należący do modelu Post), miejscu oraz zachowaniu które wywoła usunięcie rekordu (Kliknięcie przycisku \verb+Delete+ na stronie z postami) oraz o warunkach końcowych, jakie muszą zostać spełnione w wyniku działania naszej nowej funkcji (Post powinien zniknąć z listy).
    \end{description}
    
    \begin{figure}[h]
  		\begin{center}
  			\includegraphics[width=\linewidth]{images/administer_story_desc.png}
  			\caption{Szczegółowy opis zadania}
  			\label{administer_story_desc}
  		\end{center}
  	\end{figure}
  	
  	\subsubsection{Czynności wstępne}
  	
  	Po zapoznaniu się i zrozumieniu istoty problemu, z którym będziemy się zmagać należy przygotować środowisko pracy. W naszym wypadku składają się na to dwie ważne czynności:
  	
  	 \begin{description}
        \item[Upewnienie się, że posiadamy aktualną wersję oprogramowania] Zawsze powinniśmy rozpocząć pracę z najnowszą rozwojową wersją kodu.
        \item[Uruchomienie pełnego zestawu testów] Przed rozpoczęciem pracy należy upewnić się, że wszystkie testy kończą się sukcesem.
      \end{description}
      
    Kod biblioteki \emph{administer} przechowywany jest w rozproszonym systemie kontroli wersji GIT, spełnienie pierwszego punktu wymaga więc od programisty jedynie synchronizacji swojego lokalnego repozytorium z najnowszą wersją rozwojowej gałęzi kodu znajdującej się w głównym repozytorium. Szczegóły dotyczące operacji na systemie kontroli wersji wykraczają poza ramy tej pracy i zostaną tutaj pominięte. Przyjmijmy jednak, że synchronizacja została wykonana i mamy u siebie najnowszą wersję kodu biblioteki \emph{administer}. 
    
    Uruchomienie pełnego zestawu testów daje nam pewność, że wersja oprogramowania, na której będziemy pracować spełnia warunki specyfikacji. Nie wolno rozpoczynać pracy jeśli testy z jakiegoś powodu nie przechodzą. W takim wypadku należy najpierw znaleźć przyczynę problemu i zlikwidować go a pracę nad nową funkcjonalnością rozpocząć dopiero kiedy wszystkie testy automatyczne sygnalizują sukces.
    
    Aby uruchomić pełen zestaw testów biblioteki \emph{administer} wydajemy z głównego katalogu projektu polecenie:
    
    \begin{lstlisting}
      rake
    \end{lstlisting}
    
    Projekt został tak skonfigurowany, że komenda \verb+rake+ wywołana bez dodatkowych parametrów uruchamia zestaw scenariuszy Cucumber oraz testów RSpec opisujących zachowanie biblioteki. 
    
    
    
    \begin{figure}[!h]
  		\begin{center}
  			\includegraphics[width=\linewidth]{images/spec_report.png}
  			\caption{Zestaw testów RSpec - raport.}
  			\label{spec_report}
  		\end{center}
  	\end{figure}
  	
  	\clearpage
  	
  	\begin{figure}[!h]
  		\begin{center}
  			\includegraphics[width=\linewidth]{images/features_report.png}
  			\caption{Zestaw scenariuszy Cucumber - raport.}
  			\label{features_report}
  		\end{center}
  	\end{figure}
  	
  	  Raport po pozytywnym przejściu wszystkich testów powinien wyglądać podobnie jak na ilustracji \ref{spec_report} oraz \ref{features_report}. Oznaczenie \verb+pending+ przy jednym z testów RSpec sygnalizuje, że został tymczasowo wyłączony z zestawu testów przez jednego z programistów. Przyczyny wyłączenia testów mogą być różne, ale proceder ten należy stosować w ostateczności i w pełni świadomie, niedopuszczalne jest wyłączanie testu bez wyraźnego powodu a najlepiej jest, żeby takie sytuacje w ogóle się nie zdarzały.
  	  
  	\subsubsection{Więcej testów}
  	  Proces implementacji zaczyna się od stworzenia scenariusza opisującego nową funkcjonalność. W naszym przypadku scenariusze umieszczone są w podkatalogu \verb+spec/rails_root/features/+. Nas szczególnie interesuje plik \verb+spec/rails_root/features/administer/posts.feature+ w którym opisane jest zachowanie wymagane od panelu administrującego blogiem. W momencie pisania tego rozdziału plik \verb+posts.feature+ wygląda następująco:
  	  
  	\lstinputlisting{examples/code/ch04/02}
  	
  	Powyższe scenariusze opisują zachowanie biblioteki w tym momencie życia projektu, funkcja usuwania rekordu nie jest jeszcze opisana, nie pozostaje nam nic innego jak dopisać odpowiedni scenariusz:
  	
  	\lstinputlisting{examples/code/ch04/03}
  	
  	Oryginalny opis zadania (Ilustracja \ref{administer_story_desc}) został lekko zmodyfikowany w celu lepszego dopasowania do istniejącej infrastruktury i definicji kroków. Powtórne uruchomienie zestawu testów powinno zakończyć się niepowodzeniem - dodany przez nas scenariusz specyfikuje funkcjonalność, której jeszcze nie ma. Sytuację ilustruje zrzut ekranu \ref{scenario_failure}.
  	
  	\clearpage
  	
  	\begin{figure}[!h]
  		\begin{center}
  			\includegraphics[width=\linewidth]{images/scenario_failure.png}
  			\caption{Nowo dodany scenariusz nie przechodzi}
  			\label{scenario_failure}
  		\end{center}
  	\end{figure}
  	
  	Oprócz informacji o błędzie, dostajemy również informacje o tym, że jeden z kroków scenariusza jest nie zdefiniowany:
  	
  	\begin{lstlisting}
    Undefined step: "the post should disappear from posts list" (Cucumber::Undefined)
    features/administer/posts.feature:53:in `Then the post should disappear from posts list'
    \end{lstlisting}
    
    Z problemem tym można poradzić sobie na dwa sposoby: dodać nową definicję dla kroku \verb+the post should disappear from posts list+ lub zmodyfikować scenariusz tak, aby korzystał z istniejących kroków nie zmieniając jednocześnie jego sensu. Generalnie rzecz biorąc niepotrzebne tworzenie nowych bytów nie jest dobrym pomysłem, należy przyjrzeć się więc czy możliwe jest wykorzystanie już istniejących definicji kroków, żeby opisać interesujące nas zachowanie. Plik
    
    \begin{lstlisting}
    spec/rails_root/features/step_definitions/post_steps.rb
    \end{lstlisting}
    
    definiuje następujące kroki:
    
    \lstinputlisting[language=ruby]{examples/code/ch04/05}
    
    Krok opisujący zniknięcie rekordu z listy można tak naprawdę opisać przy pomocy dwóch innych kroków, po pierwsze po kliknięciu przycisku \verb+Delete+ powinniśmy upewnić się, że nadal jesteśmy na liście Postów, po drugie wiedząc, że istniał tylko jeden post, po wciśnięciu \verb+Delete+ nie powinien istnieć żaden. Wykorzystamy więc dwa już zdefiniowane kroki: 
    
    \begin{lstlisting}
    I should be on administer posts list
    \end{lstlisting}
    
    oraz 
    
    \begin{lstlisting}
    there should be no posts
    \end{lstlisting}
    
    Zmodyfikowany scenariusz wygląda następująco:
    
    \lstinputlisting{examples/code/ch04/06}
    
    Powtórne uruchomienie testów nadal sygnalizuje niepowodzenie, jednak wszystkie kroki są zdefiniowane. Jedyne nad czym musimy się teraz skupić to dostarczenie funkcjonalności, która spełni warunki nowego scenariusza.
     
     \clearpage
     
     \begin{figure}[!h]
   		\begin{center}
   			\includegraphics[width=\linewidth]{images/scenario_failure_2.png}
   			\caption{Nowo dodany scenariusz nie przechodzi, wszystkie kroki są zdefiniowane.}
   			\label{scenario_failure_2}
   		\end{center}
   	\end{figure}
   	
   \subsubsection{Dostarczenie wymaganej funkcjonalności}
   
   Nasze następne działania polegać będą na zaspokajaniu oczekiwań kolejnych kroków zdefiniowanego przez nas scenariusza aż do momentu ich wyczerpania i tym samym dostarczenia wymaganej funkcjonalności. Jak widać na ilustracji \ref{scenario_failure} dwa pierwsze kroki są zielone, skupmy się więc na trzecim z nich. Wszystko co musimy wiedzieć o przyczynach jego niepowodzenia zawarte jest w raporcie z przebiegu scenariusza:
   
   \begin{lstlisting}
   And I press "Delete"   # features/step_definitions/web_steps.rb:27
   
   no button with value or id or text 'Delete' found (Capybara::ElementNotFound)
   ./features/step_definitions/web_steps.rb:29
   ./features/step_definitions/web_steps.rb:14:in `with_scope'
   ./features/step_definitions/web_steps.rb:28:in `/^(?:|I )press "([^"]*)"(?: within "([^"]*)")?$/'
   features/administer/posts.feature:52:in `And I press "Delete"'
   \end{lstlisting}
   
   Przycisk \verb+Delete+ nie istnieje, dodajmy go do odpowiedniego widoku. Plik którego szukamy to 
   
   \begin{lstlisting}
   app/views/administer/entities/index.html.haml
   \end{lstlisting}
   
   Definiuje on widok panelu administracyjnego zobrazowany na ilustracji \ref{administer_index}
   
   \clearpage
   
    \begin{figure}[!h]
  		\begin{center}
  			\includegraphics[width=\linewidth]{images/administer_index.png}
  			\caption{Lista rekordów wybranego modelu}
  			\label{administer_index}
  		\end{center}
  	\end{figure}
  	
  Jest to ten sam widok, o którym mowa w scenariuszu. Naszym zadaniem będzie dodać przycisk \verb+Delete+ w kolumnie \verb+Actions+ dla każdego wyświetlanego rekordu. Przyjrzyjmy się naszemu widokowi od środka:
  
  \lstinputlisting[numbers=left]{examples/code/ch04/07}
  
  Powyższy kod to prosty język szablonów HAML, który jest dynamicznie przetwarzany do postaci HTML zrozumiałej dla przeglądarki. Jeśli zlokalizujemy w nim kod odpowiedzialny za wyświetlenie linka \verb+Edit+ to prawdopodobnie bardzo łatwo będzie nam dodać pod nim przycisk \verb+Delete+. Interesujący nas fragment znajdziemy w 17 linii:
  
  \lstinputlisting[firstline=17,lastline=17]{examples/code/ch04/07}
  
  Modyfikujemy kod szablonu dodając brakujący przycisk, który połączony jest z akcją odpowiedzialną za usunięcie odpowiedniego rekordu. Po modyfikacji interesujący nas fragment kodu wygląda następująco:
  
  \lstinputlisting{examples/code/ch04/08}
  
  Dla zachowania poprawnej semantyki dokumentu dodanych zostało kilka tagów HTML, jednak najważniejsza deklaracja to:
  
  \lstinputlisting[firstline=4,lastline=4]{examples/code/ch04/08}
  
  Kod ten składa się z metod implementowanych przez framework Rails oraz metod specyficznych dla samego projektu \emph{administer}. W wyniku jego działania wygenerowany zostanie przycisk o etykiecie \verb+Delete+ powiązany z metodą \verb+destroy+ kontrolera, który odpowiedzialny jest za zarządzanie rekordami modeli biznesowych przez bibliotekę \emph{administer}. W kontekście naszych rozważań na temat testowo zorientowanych metod rozwoju oprogramowania istotne jest, że modyfikacja ta zaspokaja wymaganie kroku scenariusza, nad którym aktualnie pracujemy. Uruchommy ponownie zestaw testów, aby przekonać się, że mimo iż przycisk \verb+Delete+ w tej chwili istnieje, to jednak ciągle są problemy z tym samym krokiem, informacja o niepowodzeniu jest jednak inna niż poprzednio:
  
  \begin{lstlisting}
  And I press "Delete"  # features/step_definitions/web_steps.rb:27
  
  The action 'destroy' could not be found for Administer::EntitiesController (AbstractController::ActionNotFound)
  ./features/step_definitions/web_steps.rb:29
  ./features/step_definitions/web_steps.rb:14:in `with_scope'
  ./features/step_definitions/web_steps.rb:28:in `/^(?:|I )press "([^"]*)"(?: within "([^"]*)")?$/'
  features/administer/posts.feature:52:in `And I press "Delete"'
  \end{lstlisting}
  
  Wyświetlamy przycisk \verb+Delete+ oraz jest on prawidłowo skojarzony z akcją \verb+destroy+ kontrolera \verb+Administer::EntitiesController+. Problem w tym, że akcja \verb+destroy+ nie została jeszcze zaimplementowana co skutkuje błędem - próbą uruchomienia nieistniejącej akcji w momencie kiedy użytkownik (W tym wypadku symulowany przez bibliotekę Capybara) klika w przycisk.
  
  Przejdźmy więc do wyżej wymienionego kontrolera \verb+EntitiesController+. Jego głównym zadaniem jest obsługa żądań związanych z modelami biznesowymi istniejącymi w aplikacji, która korzysta z biblioteki \emph{administer} do zadań tych zaliczają się m.in dodawanie, modyfikowanie i usuwanie rekordów tych modeli. Pełen kod kontrolera wygląda w tym momencie następująco:
  
  \lstinputlisting[language=ruby]{examples/code/ch04/09}
  
  Kontroler ten definiuje akcje, które użytkownik może za jego pomocą wykonać, oprócz tego robi kilka innych ciekawych rzeczy. Przede wszystkim ustala informację o rodzaju modelu, na którym ma przeprowadzać operacje. Nazwa modelu jest przekazywana jako jeden z parametrów żądania (\verb+params[:model_name]+) i to na jej podstawie znajdowana jest właściwa klasa reprezentująca ten model, konkretne jego rekordy, lub cała ich kolekcja.
  W tej chwili istnieją cztery akcje: \verb+new+, \verb+create+, \verb+edit+ oraz \verb+update+ brakuje (o czym zostaliśmy już poinformowani przez nieprzechodzący scenariusz) akcji \verb+destroy+, której implementacją zajmiemy się w tej chwili.
  
  Z treści naszego scenariusza wynika, że zadaniem akcji \verb+destroy+ jest usunięcie konkretnego rekordu z bazy danych oraz przekierowanie użytkownika z powrotem na listę wszystkich rekordów. Na wejściu akcja musi więc otrzymać dwa parametry: nazwę modelu oraz identyfikator rekordu a na podstawie tych danych wykonać polecenie które usunie rekord należący do tego modelu oraz noszący taki właśnie identyfikator. Kod spełniający taką specyfikacje może wyglądać następująco: 
  
  \lstinputlisting[language=ruby,numbers=left]{examples/code/ch04/10}
  
  Po dodaniu metody \verb+destroy+ do kontrolera uruchamiamy testy raz jeszcze przy pomocy polecenia \verb+rake+. Tym razem wszystkie scenariusze przechodzą.
  
  \clearpage
  
   \begin{figure}[!h]
 		\begin{center}
 			\includegraphics[width=\linewidth]{images/delete_record_scenario_pass.png}
 			\caption{W tym momencie funkcjonalność spełnia wymagania scenariusza.}
 			\label{delete_record_scenario_pass}
 		\end{center}
 	\end{figure}
 	
 	Teoretycznie moglibyśmy w tym momencie uznać zadanie za zakończone, jednak pisząc metodę \verb+destroy+ wykroczyliśmy nieco poza to, co opisane zostało w scenariuszu, linie 3-5 definiują następujący blok kodu:
 	
 	\lstinputlisting[language=ruby,firstline=3,lastline=5]{examples/code/ch04/10}
 	
 	Jeśli usunięcie rekordu z jakiejś przyczyny nie zakończy się powodzeniem wyświetlony zostanie komunikat o treści:
 	
 	\begin{lstlisting}
 	Could not destroy object.
 	\end{lstlisting}
 	
 	Zachowanie to jest jak najbardziej sensowne, zostało ono jednak dodane samowolnie i nie jest nigdzie przetestowane. Jako odpowiedzialni programiści nie powinniśmy dopuścić do takiej sytuacji i dopisać odpowiedni test. Przetestowanie tego zachowania scenariuszem Cucumber jest trudne, trudno bowiem odtworzyć sytuację, w której usunięcie rekordu zakończy się niepowodzeniem - może się tak stać np. kiedy silnik bazy danych w której jest przechowywany nałożył na ten rekord blokadę, która trwa w momencie próby jego usunięcia. W tej sytuacji do testowania wykorzystamy bibliotekę RSpec i jej mechanizm oczekiwań oraz sztucznych obiektów. Odpowiedni zestaw testów zdefiniowany jest w pliku:
 	
 	\begin{lstlisting}
 	spec/rails_root/spec/controllers/administer/entities_controller_spec.rb
 	\end{lstlisting}
 	
 	W którym następująco opiszemy interesujące nas zachowanie:
 	
 	\lstinputlisting[language=ruby]{examples/code/ch04/12}
 	
 	Upewniliśmy się, że informacja o błędzie została ustawiona w kontrolerze. To jednak nie wszystko, musimy sprawdzić, czy jest ona wyświetlona w odpowiednim widoku. \emph{Administer} wyświetla informacje o błędach w głównym widoku zdefiniowanym w pliku:
 	
 	\begin{lstlisting}
 	app/views/layouts/administer.html.haml
 	\end{lstlisting}
 	
 	Odpowiedni test ma sprawdzać, czy ustawiony komunikat zostanie wyświetlony:
 	
 	\lstinputlisting[language=ruby]{examples/code/ch04/13}
  
  \section{Wnioski}
